# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWQUfMQ1dzqoafoEE9T1Lly84uHqPKWX
"""

!pip install opencv-python

# ده طبقات الجراي
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

# Read the image
image = cv2.imread('/content/6_october_bridge (13).jpg')

# Convert the image to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Sobel operator in the x direction
sobel_x = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=3)

# Apply Sobel operator in the y direction
sobel_y = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=3)

# Compute the magnitude of the gradient
sobel_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)
sobel_magnitude = np.uint8(np.absolute(sobel_magnitude))

# Normalize the result to the range 0 to 255
sobel_magnitude = cv2.normalize(sobel_magnitude, None, 0, 255, cv2.NORM_MINMAX)

# Display the results
cv2_imshow(image)  # Display original image
cv2_imshow(sobel_x)  # Display Sobel X
cv2_imshow(sobel_y)  # Display Sobel Y
cv2_imshow(sobel_magnitude)  # Display Sobel Magnitude

# Save the result if needed
cv2.imwrite('sobel_x.jpg', sobel_x)
cv2.imwrite('sobel_y.jpg', sobel_y)
cv2.imwrite('sobel_magnitude.jpg', sobel_magnitude)



# ده sobel x,y
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image = cv2.imread('/content/6_october_bridge (13).jpg')

# Convert the image to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Sobel operator in the x direction
sobel_x = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=3)

# Apply Sobel operator in the y direction
sobel_y = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=3)

# Compute the magnitude of the gradient
sobel_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)
sobel_magnitude = np.uint8(np.absolute(sobel_magnitude))

# Normalize the result to the range 0 to 255
sobel_magnitude = cv2.normalize(sobel_magnitude, None, 0, 255, cv2.NORM_MINMAX)

# Display the results
plt.figure(figsize=(12, 6))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))

plt.subplot(1, 3, 2)
plt.title('Sobel X')
plt.imshow(sobel_x, cmap='gray')

plt.subplot(1, 3, 3)
plt.title('Sobel Y')
plt.imshow(sobel_y, cmap='gray')

plt.figure()
plt.title('Sobel Magnitude')
plt.imshow(sobel_magnitude, cmap='gray')

plt.show()

# Save the result if needed
cv2.imwrite('path_to_save_sobel_x.jpg', sobel_x)
cv2.imwrite('path_to_save_sobel_y.jpg', sobel_y)
cv2.imwrite('path_to_save_sobel_magnitude.jpg', sobel_magnitude)

#ده Adaptive threshold
import cv2

from google.colab.patches import cv2_imshow

# Read the image
image = cv2.imread('/content/6_october_bridge (13).jpg', cv2.IMREAD_GRAYSCALE)

# Apply Gaussian adaptive thresholding
adaptive_thresh_gaussian = cv2.adaptiveThreshold(
    image,
    255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY,
    11,  # Block size
    2   # Constant C subtracted from the mean or weighted mean
)

# Apply Mean adaptive thresholding
adaptive_thresh_mean = cv2.adaptiveThreshold(
    image,
    255,
    cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY,
    11,  # Block size
    2   # Constant C subtracted from the mean
)

# Display the results
cv2_imshow(image)  # Display original grayscale image
cv2_imshow(adaptive_thresh_gaussian)  # Display Gaussian adaptive thresholding result
cv2_imshow(adaptive_thresh_mean)  # Display Mean adaptive thresholding result

# Save the results if needed
cv2.imwrite('adaptive_thresh_gaussian.jpg', adaptive_thresh_gaussian)
cv2.imwrite('adaptive_thresh_mean.jpg', adaptive_thresh_mean)

#ده image segment
import cv2
from google.colab.patches import cv2_imshow

# Read the image
image = cv2.imread('/content/6_october_bridge (13).jpg', cv2.IMREAD_GRAYSCALE)

# Apply global thresholding
_, global_thresh = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)

# Apply adaptive mean thresholding
adaptive_thresh_mean = cv2.adaptiveThreshold(
    image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply adaptive Gaussian thresholding
adaptive_thresh_gaussian = cv2.adaptiveThreshold(
    image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Display the results
cv2_imshow(image)  # Display original grayscale image
cv2_imshow(global_thresh)  # Display global thresholding result
cv2_imshow(adaptive_thresh_mean)  # Display adaptive mean thresholding result
cv2_imshow(adaptive_thresh_gaussian)  # Display adaptive Gaussian thresholding result

# Save the results if needed
cv2.imwrite('global_thresh.jpg', global_thresh)
cv2.imwrite('adaptive_thresh_mean.jpg', adaptive_thresh_mean)
cv2.imwrite('adaptive_thresh_gaussian.jpg', adaptive_thresh_gaussian)

# ده canny detection
import cv2
from google.colab.patches import cv2_imshow

# Read the image in grayscale
image = cv2.imread('/content/6_october_bridge (13).jpg', cv2.IMREAD_GRAYSCALE)

# Apply GaussianBlur to reduce noise and improve edge detection
blurred = cv2.GaussianBlur(image, (5, 5), 0)

# Apply Canny edge detector
edges = cv2.Canny(blurred, 100, 200)

# Display the original image and the edge-detected image
cv2_imshow(image)  # Display original grayscale image
cv2_imshow(edges)  # Display edges

# Save the result if needed
cv2.imwrite('edges.jpg', edges)

# ده laplacian
import cv2
from google.colab.patches import cv2_imshow

# Read the image in grayscale
image = cv2.imread('/content/6_october_bridge (13).jpg', cv2.IMREAD_GRAYSCALE)

# Apply GaussianBlur to reduce noise and improve edge detection
blurred = cv2.GaussianBlur(image, (3, 3), 0)

# Apply Laplacian edge detector
laplacian = cv2.Laplacian(blurred, cv2.CV_64F)

# Convert the absolute values to 8-bit image
laplacian = cv2.convertScaleAbs(laplacian)

# Display the original image and the edge-detected image
cv2_imshow(image)  # Display original grayscale image
cv2_imshow(laplacian)  # Display Laplacian edges

# Save the result if needed
cv2.imwrite('laplacian_edges.jpg', laplacian)

# بعد ما حولت لgray ممكن اعمل contours about image
import cv2
from google.colab.patches import cv2_imshow

# Read the image in grayscale
image = cv2.imread('/content/edges.jpg', cv2.IMREAD_GRAYSCALE)

# Apply GaussianBlur to reduce noise and improve edge detection
blurred = cv2.GaussianBlur(image, (5, 5), 0)

# Apply Canny edge detector
edges = cv2.Canny(blurred, 100, 200)

# Find contours
contours, hierarchy = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Draw contours on the original image (convert grayscale to BGR for color display)
image_with_contours = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
cv2.drawContours(image_with_contours, contours, -1, (0, 255, 0), 2)

# Display the original image, edge-detected image, and image with contours
cv2_imshow(image)  # Display original grayscale image
cv2_imshow(edges)  # Display edges
cv2_imshow(image_with_contours)  # Display image with contours

# Save the result if needed
cv2.imwrite('edges.jpg', edges)
cv2.imwrite('image_with_contours.jpg', image_with_contours)

